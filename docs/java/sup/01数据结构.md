---
lang: zh-CN
title: 数据结构
description: sup 01
---

常见的数据结构有：堆，栈，队列，数组，链表（单、双），树（二叉树、红黑树、B树、B+树），图，散列表

常见算法有：排序（冒泡、插入、快排），查找（二分、哈希、二叉树），分治，动态规划，回溯，贪心法


#### 栈stack

先进后出，出入口都是栈顶位置，仅允许在表的一端进行插入和删除

存的是：局部变量，生命周期短，自动分配释放，使用的是一级缓存，先进后出

栈的物理地址分配是连续的，性能快；

分配的内存大小在编译期确认，大小固定；

栈存放局部变量、操作数栈、返回结果等；

栈只对于线程是可见的。


#### 堆heap

存的是：数组和对象（数组就是对象），实体，GC，程序员分配释放，二级缓存

堆的物理地址分配是不连续，性能慢；

分配的内存在运行期确认，大小不固定；

堆存放对象的实例和数组；

堆对于整个应用程序都是共享可见的。


### 压栈

存元素

### 弹栈

取元素

# 队列queue

仅允许在表的一端插入，在另一端删除

先进先出

# 数组Array

有序，查找元素快，但增删慢

# 链表Linked List

由一系列结点node组成，node包括数据域data和指针域next两部分

### 单向链表

多个结点之间，通过地址进行连接，查找慢，增删快

### 双向链表

‍
# 二叉树Binary tree

### 红黑树

二叉树的一种

顶上----根节点（黑色）

两边----左子树，右子树

叶子节点是黑色

速度特别快，趋近平衡树

‍

#### 链表

以链表方式存储的元素一般被称为：节点

节点由三部分组成：当前元素的地址值+数据源+下一个元素的地址值

链表分类：单链表、双链表

单链表：只有一个链子用于连接前后的元素不能保证数据的有序
双链表:  一条链子用于连接前后两个元素，另一条链子用于记录其存储顺序


查询慢: 每次查找元素的时候都需要从头开始查找
增删快: 增加删除的时候不用改变整个数据结构只需要改变前后两个元素




### set集合

A.Set集合是Collection
B.特点:
a.不可重复  b.无序(存与取的顺序不一致)(没有索引)
C.实现类



### hashSet

1.hashcode值是根据内存地址生成的一个十进制的整数
2.获取hashCode值的方法
public int hashCode() 返回该对象的哈希码值
3.不能根据hashcode值来判断两个的对象是否是同一个对象 因为自定义的类 一般会重写hashCode方法
4.字符串是重写的hashcode()方法 字符串的内容相同 hashcode值也相同
5.注意点:
字符串可能会出现hash冲突  字符串的内容不同 但是hashcode值是相同



### 红黑树

A.此类实现 Set 接口
B.以hash表结构存储
C.不保证 set 的迭代顺序 无序
D.允许使用 null 元素
E.此实现不是同步的  在多线中也是不安全
F.实例集合的默认初始容量是 16



### TreeSet

1.特点
A.基于 TreeMap 的 NavigableSet 实现
B.使用元素的自然顺序对元素进行排序
C.提供这两个接口 Comparable 或 Comparator 设置排序规则
D.此实现不是同步的 在多线程中不安全
2.默认的排序规则:
A.对于数值类型 是从小到大进行排序
B.对于字符串类型数据 是按照字符串的首字母的ascmll来进行排序
C.对于自定义类的数据类型 需要指定排序规则 否则添加集合中就会报错
3.自定的类型的排序规则
A.定义类实现Comparable
a.this -object  >0 正数 升序
b.this -object  =0  表示是相同的元素 不会存入集合中
c.this - object <0  负数 降序
B.实例化集合的时候传递比较的规则









#### 队列

先进先出

#### 对象在内存布局

栈-->堆[基本数据类型直接在此存放]-->方法区（常量池）引用数据类型在这里存放

#### （成员）方法

方法的调用机制

#### 递归

方法自己调用自己