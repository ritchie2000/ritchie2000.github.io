---
lang: zh-CN
title: 反射
description: sup 09
---

## 反射reflection

Java的反射机制是指在运行状态中,对于任意一个类都能够知道这个类所有的属性和方法,并且对于任意一个对象,都能够调用它的任意一个方法,这种动态获取信息以及动态调用对象方法的功能称为Java的反射机制。

反射就是把java类中的各种成分映射成一个个的Java对象

- 反射中，可把方法视为对象

- 用方法对象 来调用 方法

- 运行时期，动态创建对象

**反射有什么用**

1，在运行时判断任意一个对象所属的类；

2，在运行时构造任意一个类的对象；

3，在运行时判断任意一个类所具有的成员变量和方法；

4，在运行时调用任意一个对象的方法；

5，生成动态代理。

‍

#### 通过配置文件，在不改变源码的情况下，来控制程序，符合ocp开闭原则

‍

#### 反射中常见的API:

#### Class类

是描述类的类，可以获取一个类的描述，类中属性，方法，构造器的信息等

- 没有构造方法，只能由系统创建

- 一个class对象对应的是一个加载到jvm中的一个.class文件

**获取class类对象的方法****：**

3. Class.forName()静态方法，多用于配置文件

```Java
Class<?> aClass = Class.forName("com.qf.javase.day22.Exe1.User");
```


4. 类的.class方法，多用于参数传递

```Java
Class<User> aClass2 = User.class;
```


5. 使用实例对象的getClass方法

```Java
User user = new User();
        Class<? extends User> aClass3 = user.getClass();
```


6. ClassLoader类加载器

```Java
Class<? extends ClassLoader> aClass4 = User.class.getClassLoader().getClass();
```


‍

#### method描述方法的类

getMethods获取所有public修饰的方法(包含父类)

getDeclaredMethods获取当前类所有的权限修饰符修饰的方法（不包括父类）

‍

#### field描述属性的类（成员变量）

getFields返回所有的public修饰的属性,包含父类

getDeclaredFields返回当前类的所有权限的属性(不包括父类)

**setAccessible(true)给私有属性赋值需要****开启权限**

‍

#### constructor描述构造方法的类

newInstance调用无参构造方法

getConstructor调用有参构造方法

getModifiers获取构造方法的权限修饰符

‍

#### ClassLoader类加载器

getClassLoader

getResourceAsStream获取一个文件的输入流

‍

#### 代理模式Proxy Pattern

代理模式给某一个对象提供一个代理对象,并由代理对象控制对原对象的引用，代理对象在客户端和目标对象之间起到中介作用，属于结构型设计模式。

调用目标对象，增强目标对象的功能。

#### 静态代理

接口，优先于实现类

局限：每一个代理类只能代理一个接口

‍

#### 动态代理DynamicProxy

- JDK动态代理

JDK自带的动态代理类java.lang.reflect.Proxy实现动态代理
优点: 简单、方便
缺点: 只能代理接口,不能代理类

- CGLib动态代理

如果目标对象没有实现任何接口，那么只能使用CGLib动态代理

开源,功能强大高性能的代码生成库
优点: 可以代理类

‍

### 函数式接口@FunctionalInterface

- 首先它是一个接口，然后在这个接口里面有且只有一个抽象方法。

- 允许定义静态方法

- 允许定义默认方法


**反射Reflection是框架的灵魂，可以动态的创建和使用对象**

**但反射是解释执行，速度会变慢**

new和newInstance的区别：

使用newInstance有两个前提：
1.这个类已经加载；
2.这个类已经连接了。

newInstance()实际上是把new这个方式分解为两步，即首先调用Class加载方法加载某个类，然后实例化。这种分步的方式有利于解耦。

newInstance: 弱类型。低效率。只能调用无参构造。

new: 强类型。相对高效。能调用任何public构造。

```Java
public class Exe {
    public static void main(String[] args) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Properties properties = new Properties();
        properties.load(new FileInputStream("src\\re.properties"));
        String classfullpath = properties.get("classfullpath").toString();
        String method = properties.get("method").toString();

        Class cls = Class.forName(classfullpath);
        //获取已加载的类的对象实例
        Object o = cls.newInstance();

        //通过方法名method，获得一个对应的方法对象
        Method method1 = cls.getMethod(method);

        //然后通过方法对象，调用方法
        method1.invoke(o);//传统形式：对象.方法()  反射中形式：方法.invoke(对象)
    }
}

```


ocp原则：开闭原则

在不改变源码的情况下，来扩展功能



getClass获取的是运行类型


Java程序在计算机的三个阶段：

1. 代码\编译阶段
2. Class类加载阶段
3. Runtime运行阶段



#### 哪些类型有Class对象？

各种类
interface
数组
enum
annotation注解
基本数据类型
void

静态加载：编译时加载相关的类

动态加载：运行时加载需要的类，降低了依赖性



invoke（o，"实参"）；//如果是静态方法，这个对象o可以写成null
