---
title: GC
---
# GC
>Garbage Collection垃圾回收是一种回收无用内存空间并使其对未来实例可用的过程。
## GC位于哪里
>堆内存是内存数据区，用来保存运行时的对象实例。垃圾回收器会在这里操作。
在运行时，Java的实例被存放在堆内存区域。当一个对象不再被引用时，满足条件就会从堆内存移除。在垃圾回收进程中，这些对象将会从堆内存移除并且内存空间被回收。

*堆内存包括以下三个主要区域：*
1. 新生/年轻代（Young Generation）
	- Eden空间（Eden space）
	- Survivor S0 空间（也叫From区，S0 Survivor space）
	- Survivor S1 空间（也叫To区）
2. 老年代（Old Generation）实例将从S1提升到Tenured（终身代）
3. 永久代（Permanent Generation）包含类、方法等细节的元信息，JDK1.8中被移除，变成单独的元空间


**年轻代三个区比例：**  
Eden：S0：S1 = 8：1：1

## Survivor0和Survivor1
Survivor区域分为两块S0（From区）和S1（To区），都是年轻代。同一时刻只有一个区里有对象，另一个是空的。  
eg.一次GC前，Eden和S0是有对象的，S1为空，经过GC后，S0中的对象年龄+1，Eden中还存活的对象被移动到S1区，S0中还存活的对象有两个去处：  
- 1. 如果年龄达到阈值，被移动到老年代，  
- 2. 如果没有达到阈值，被移动到S1区。    

注：这时候S0和S1区域会互换，因为原来的S0已经空了，这时S0变成S1，S1变成S0。  
`Minor GC`会一直这样重复，直到S1区域满了，会把全部对象转移到老年代。

## GC回收的对象
回收的对象：
- 超出作用域的对象/引用计数为空的对象。
- 引用计数法，从`GC Root`开始搜索，搜索不到的对象。
- 从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。

## 如何判断对象/常量是否应该被回收
1. 引用计数法：给对象增加一个计数器，当引用它时，计数器就加一，当引用失效时，计数器就减一；

JVM由于循环引用会导致引用计数法失效而并没有采用这种方式。

循环引用：A类中一个属性引用了B类对象，B类中一个属性引用了A类对象。

2. 可达性分析法：通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的

路径称之为"引用链"，当一个对象到GC Roots没有任何的引用链相连时，证明此对象应该被回收。

## GC过程

Java 垃圾回收是一项自动化的过程，是由一个守护线程完成的。

1. 大多数新建的对象都位于`Eden`区，大对象会直接放到`Old`区；
2. 当`Eden`区快被对象填满时，就会触发`Minor GC`（或者叫`Young GC`），采用标记复制算法，把`Eden`区未打标记的对象（存活下来的对象）转移到`S0`区，然后清空`Eden`区和`S1`区；
3. 下一次`Minor GC`同样会检查存活下来的对象，对`Eden`区和`S0`区对象扫描打标，把未打标记的对象复制到`S1`区；
4. `S0`和`S1`区是交替的，用于存放幸存的对象，并且同一时间总有一个是空的；
5. 一次`Minor GC`后会给存活下来的对象年龄+1，当年龄达到默认的阈值15，就不再往`S`区放了，直接复制到`Old`区；
6. 当`Old`区快满时也会触发`GC`，叫`Major GC`（或者叫`Old GC`），采用的是标记清理算法，或者是标记整理算法；
7. `Major GC`会扫描老年代中的对象，如果实例不再被引用，那么它们会被标记为回收，否则它们会继续留在老年代中；  
8. `Major GC`触发时往往也会伴随着`Minor GC`，所以也叫做`Full GC`,会引起Stop，这是Java程序会暂停，全力进行`GC`，收集整个GC堆。


删除不使用的对象，会腾出大约40%内存空间。  



## 垃圾清理算法
### 标记清理算法

把需要被回收的对象进行标记，标记完之后再扫描一遍，把被标记的对象删除掉。

存在的问题：会产生内存碎片  
eg.删除掉2个1k大小的对象，然后我再放入一个2k大小的对象，是不能直接放到刚才腾出来的2k空间里的，也不能拆分，那么这2个1k空间可能会一直存在。

为解决这个问题，就有了另一种算法：

### 标记整理算法

原理是删掉一个对象后，后面的对象往前顶，这样就能避免出现内存碎片的问题，但是开销比较大，很多对象都要移动，代价太大。

### 标记复制算法

将整个内存一分为二，一个区放对象，另一个区是空的。  
eg.在第一个区给对象打标记，不需要删除的对象也就是没打标记的给他复制到另一个空区域，再把这个区域清空。

缺点的话就是比较浪费内存。

>`Minor GC`采用标记复制算法，是因为新生代大多数对象（约占总体的98%）都会在第一次GC中消亡。

## 垃圾收集器

### CMS收集器 
Concurrent Mark Sweep，是一种以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现。JDK1.7之前的默认垃圾回收算法，并发收集，停顿小。

### G1收集器 
Garbage First，是一款面向服务端应用的垃圾收集器。JDK1.8就有了，从Java 9开始设为默认，特点是保持高回收率的同时，减少停顿。

### ZGC收集器
Z Garbage Collector，是一种可伸缩的低延迟垃圾收集器。java 11开始有了。

ZGC的一个核心设计就是读屏障与彩色指针(colored object pointers, 缩写, colored oops)组合起来使用总体来说是一种利用64位指针中未使用的bit来保存元数据的指针。这是ZGC可以与用户线程并发执行的原因。



