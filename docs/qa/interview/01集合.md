---
title: 集合
---
## 1、数组、链表、集合？
  - 数组：
    是有序的元素序列，用于储存多个相同类型数据的集合。
    可存基本数据类型、引用数据类型
    静态分配内存
    在内存中连续
    元素在栈区
    长度不可变
    空间连续
    优点：查改快
    数组int范围-2^31 ~~ 2^31-1
    问题缺点：增删慢
    使用情景：元素个数固定时

  - 链表：
    是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。
    链表出现原因：为了解决hash冲突
    动态分配内存，减少内存空间浪费
    在内存中不连续
    元素在堆区
    优点：增删快
    缺点：查询慢 ---- 跳表技术
    
  - 集合：
    是一个用来存放对象的容器
    集合出现的原因：一旦在初始化数组时指定了数组长度，这个数组长度就是不可变的。为了保存数量不确定的数据，有了集合。
    集合只能存引用数据类型（对象的引用），存储基本数据类型会自动装箱成包装类对象
    长度可变；空间不连续，增删快
    数组可以存基本数据类型（值），也可以存引用数据类型（地址值）
    定义数组时必须指定元素类型；长度不可变；空间连续，查改快
    使用情景：元素个数不固定时

## 2、集合？
  - 集合可分为 Collection 和 Map 两种体系
  - Collection接口：单列数据，定义了存取一组对象的方法的集合
  - Map接口：双列数据，保存具有映射关系“key-value键值对”的集合
  ![](https://img2022.cnblogs.com/blog/2968215/202209/2968215-20220907130700988-518575599.png)

## 3、HashMap底层原理？
  - 数组+链表+红黑树
  - hashcode --> MD5
  - 哈希算法：又称散列
    - 任意长度输入-->固定长度输出
  - 通过字符串算出它的ascii码，mod取模，算出下标；
  - mod：解决数组连续的问题，减少浪费空间，带来新的问题：hash冲突/碰撞
  - 解决hash冲突：链表
  - put（key，value）{hash(key)}方法
    - 通过key进行hash算法算出hashcode值-->取模mod得到下标位置-->去数组找到下标对应的Entry对象，当前对象是否为空，if空直接存储key和value，if不为空，用链表，最后返回
  - hashcode作用：定位在链表上的位置
  - jdk1.8之后，将头插法改成尾插法，加了红黑树（因为链表查询慢）
    - 红黑树快的原因：小中大、左中右
    - 尾插法：不会影响原有的顺序，解决了节点相连成环的问题
  - 默认容量16，负载因子0.75，当链表长度大于等于8，将以红黑树形式存储，当长度降到6，转成链表
  - 无序，速度快，允许null键和null值，不支持线程同步，线程不安全

## 4、Collection和Collections的区别?
  - Collection：是集合类的上级接口，继承它的接口主要有Set、List；
  - Collections类：是一个操作集合的算法工具类，只能操作Collection接口下的集合（Map集合不能使用该类）提供了一系列静态方法实现对各种集合的搜索、排序、线程安全等操作
    - sort自然排序
    - swap交换两元素的位置
    - reverse反转集合

## 5、Vector、ArrayList和LinkedList的区别？
  - Vector：底层是数组，线程安全，初始容量10，查询快，线程安全；
  - ArrayList：底层是数组，线程不安全，初始容量0->10，查询快，线程不安全；
  - LinkedList：底层是链表，线程不安全，初始容量无，增删快，线程不安全。

    - 事先不知道数组大小 --> vector
    - 频繁访问列表中的某一元素 --> ArrayList
    - 循环迭代访问列表 --> LinkedList

## 6、list、set、map的区别？
  - list：继承collection接口，有序，可以重复，线程不安全，增删慢，查询快；
  - set：继承collection接口，无序，不重复，线程不安全，增删快，查询慢；
  - map：与collection接口并列，键唯一，value可重复，线程不安全，增删改查都快；
    - *set出现的原因：去重 --> 哈希值和equals方法

## 7、HashSet和TreeSet和LinkedHashSet区别？
  - HashSet：基于HashMap实现，无序的；
  - TreeSet：基于TreeMap实现，底层是红黑树，有序的；
  - LinkedHashSet：内部是双向链表，有序的

## 8、HashMap和Hashtable的比较？
  - HashMap异步的，线程不安全，可以存null键和null值，效率高，初始大小16，扩容2的幂次方
  - Hashtable是同步的，线程安全，不可以存null键和null值，效率低，初始大小11，扩容2n+1

## 9、HashMap和ConcurrentHashMap区别？
  - HashMap：全局锁不同步，线程不安全，不适用多线程并发环境，
  - ConcurrentHashMap：分段锁，只能保证单个方法同步，线程安全的集合容器，效率更高

## 10、HashMap和LinkedHashMap的区别？
  - LinkedHashMap继承于HashMap，底层基于HashMap和双向链表实现，有序，比HashMap多了一个链表的结构
  - HashMap存储和取出都是无序的，LinkedHashMap取出是有序的

## 11、ArrayList、LinkedList、HashMap初始大小，add后是多少？(jdk1.8)
  - ArrayList：new 0 空数组没添加元素时为0，初始容量10，扩容因子1.5，eg.10-->15-->22，最大值Integer.MAX_VALUE-8；
  - LinkedList：没有初始化大小，也没有扩容的机制；
  - HashMap：初始大小16，扩容（负载）因子0.75，eg.容量16的HashMap，当插入第13个元素时，就会扩容成当前数组的2倍的新数组，hashcode会变。


