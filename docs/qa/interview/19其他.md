---
title: 其他
---


3\*0.1 == 0.3 true or false

计算机语言进行浮点运算时有偏差（1.为什么有偏差？，2.每种语言一样吗？）

‍

有偏差的原因：计算机存值方式，进制

每种语言不一样（不一样的原因是打印方式不同），常见的c语言精度最高

计算机存值的方式：它只能存整数，没有计算小数的能力，也没有乘除法（通过二进制进退位加减法计算），通过位移量，定点数开头的0和1来确定是否是小数点（假设计算机-内存-元器件通电表示1，断电表示0），浮点FP后数字越大，精度越高，计算机更耗电，性能越弱，科学计数法：V = (-1)^s^ x M x 2^E^

‍

10的质因子（能整除给定正[整数](https://baike.baidu.com/item/%E6%95%B4%E6%95%B0/1293937)的[质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515)）有2和5，可以精确表示1/（2、4、5、8、10），所以我们常见的1/(3、6、7)都是循环小数，因为他们的分母使用了质因子3或7。

2的质因子只有2，可以精确表示1/2,1/4,1/8,1/16.....

定点运算：以定点格式存储小数，小数点位置固定，*优点是精度高，因为所有的位都用来存储有效数字了，缺点是取值范围太小，不能表示很大或者很小的数字。*

浮点运算：以指数的形式来存储小数，小数点位置不固定，优点是节省内存，取值范围更大，缺点是精度低。

‍

更精度计算方法：

超过16位有效位数的运算，用BigDecimal，它创建的是一个对象，提供有4个构造方法进行运算

‍

‍

\$ \{\}是字符串替换，\#\{\}是预编译处理。

mybatis在处理两个字符时，处理的方式也是不同的：

1. 在处理 \时，就是把\{ \} 替换成变量的值；

2. 处理\#\{\}时，会将sql中的\#\{\}整体替换为占位符（即：?），调用PreparedStatement的set方法来赋值；

3. 用\$\{\}来编写SQL会出现：恶意SQL注入，对于数据库的数据安全性就没办法保证了。

4. 使用 \#\{\} 可以有效的防止SQL注入，提高系统安全性：

预编译的机制？

预编译是提前对SQL语句进行预编译，而后再调用SQL，注入的参数就不会再进行SQL编译。而SQL注入是发生在编译的过程中，因为恶意注入了某些特殊字符，最后被编译时SQL时轻而易举的通过，从而导致数据泄露。而预编译机制则可以很好的防止SQL注入。

‍

s1+= 1;相当于 s1 = (short)(s1 + 1);其中有隐含的[强制类型转换](https://so.csdn.net/so/search?q=%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2&spm=1001.2101.3001.7020)

IntegerCache默认情况下范围是-128 ~ 127

执⾏ Integer a \= 128，相当于执⾏：Integer a \= Integer.valueOf\(128\)，基本类型⾃动转换为包装类的过程称为⾃动装箱（autoboxing）。

n \<\< m 相当于n乘2的m次幂

按位与运算符：⽤于⼆进制的计算，只有对应的两个⼆进位均为1时，结果位才为1 ，否则为0。 逻辑与运算符：\& 在⽤于逻辑与时，和 \&\& 的区别是不具有短路性。所在通常使⽤逻辑与运算符都会 使⽤ \&\&，⽽ \& 更多的适⽤于位运算。

基本数据类型只有8个：byte、short、int、long、float、double、char、 boolean；数据存储在**栈**上

引用类型：其他都是引用类型，数据存储在**堆**上，引用地址存储在**栈**上。

String 类使⽤ final 修饰，⽆法被继承。

值传递。Java 中只有值传递，对于对象参数，值的内容是对象的引⽤。

赋值运算符=的作用：

对于基本类型，会直接改变变量的值，原来的值被覆盖掉。

对于引用类型，会改变引用中所保存的地址，原来的地址被覆盖掉，但是原来的对象不会被改变。

‍

string类、object类

‍

#### Serializable接口

序列化：把对象的状态信息转化为可存储或传输的形式过程，对象 --> 字节序列

反序列化：把字节数组反序列化为对象，字节序列 --> 对象

**作用：**

1，存储对象在存储介质中，以便在下次使用的时候，可以很快捷的重建一个副本。

2，便于数据传输，尤其是在远程调用的时候

Serializable接口其实是个空接口，在Java IO体系中仅起一个标记的作用。没有实现Serializable接口的对象是无法通过IO操作持久化 。

**常见的序列化技术：**

1、java 序列化

2、XML序列化

3、JSON序列化

4、Hessian 序列化框架协议

阿里巴巴服务层框架Dubbo采用的就是Hessian序列化

‍

**为什么重写equals方法，还必须要重写hashcode方法**

- hashCode主要用于提升查询效率，来确定在散列结构中对象的存储地址；

- equals()相等的两个对象，hashcode()一定相等；

- hashcode()相等，equals()不一定相等



Stiring s = “a”+“b” +“c” 在JDK1.7之前创建了5个对象。
Stiring s = “a”+“b” +“c” 在JDK1.7及之后创建了1个对象。



**类与类的关系**
继承关系，只能单继承，但是可以多层继承

**类与接口的关系**
实现关系，可以单实现，也可以多实现

**接口与接口的关系**
继承关系，可以单继承，也可以多继承
